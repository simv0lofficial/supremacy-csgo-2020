#include "../../../supremacy.hpp"

namespace supremacy::hacks {
	int c_exploits::compute_type() const {
		if (!valve::g_local_player
			|| g_movement->should_fake_duck())
			return 0;

		if (sdk::g_config_system->double_tap
			&& key_handler::check_key(sdk::g_config_system->double_tap_key, sdk::g_config_system->double_tap_key_style))
			return 2;		

		if (sdk::g_config_system->hide_shots
			&& key_handler::check_key(sdk::g_config_system->hide_shots_key, sdk::g_config_system->hide_shots_key_style))
			return 1;

		return 0;
	}

	void c_exploits::manage_wpn(valve::user_cmd_t& user_cmd) {
		m_dt_ready = false;

		const auto weapon = valve::g_local_player->weapon();
		const auto wpn_data = weapon ? weapon->wpn_data() : nullptr;

		int shift_amount{};

		if ((m_type = compute_type())) {
			if (weapon) {
				const auto item_index = weapon->item_index();
				if (item_index != valve::e_item_index::taser
					&& item_index != valve::e_item_index::c4
					&& wpn_data && wpn_data->m_unk_type != 1
					&& !(item_index >= valve::e_item_index::flashbang && item_index <= valve::e_item_index::inc_grenade)) {
					if (m_ticks_allowed) {
						if (m_type == 1)
							shift_amount = 8;
						else if (m_type == 2 && g_context->can_shoot(weapon, user_cmd, false, m_ticks_allowed, false))
							shift_amount = m_ticks_allowed;

						if (valve::g_global_vars->m_cur_time >= valve::g_local_player->next_attack()) {
							m_dt_ready = true;
							m_next_shift_amount = shift_amount;
						}

						goto SKIP;
					}
				}
			}
		};

		shift_amount = m_cur_shift_amount = m_next_shift_amount = 0;
		if (!m_type
			&& m_ticks_allowed > 0) {
			m_type = 3;
			m_cur_shift_amount = m_next_shift_amount = m_ticks_allowed;

			m_charged = true;
		}

	SKIP:
		if (weapon
			&& sdk::g_config_system->enabled
			&& weapon->item_index() == valve::e_item_index::revolver) {
			g_eng_pred->r8_can_shoot() = true;

			user_cmd.m_buttons &= ~valve::e_buttons::in_attack2;

			if (g_context->can_shoot(weapon, user_cmd, true, 0, true)) {
				if (valve::g_global_vars->m_cur_time < g_eng_pred->postpone_fire_ready_time())
					user_cmd.m_buttons |= valve::e_buttons::in_attack;
				else if (valve::g_global_vars->m_cur_time < weapon->next_secondary_attack())
					user_cmd.m_buttons |= valve::e_buttons::in_attack2;
				else
					g_eng_pred->postpone_fire_ready_time() = valve::g_global_vars->m_cur_time + valve::to_time(15);

				g_eng_pred->r8_can_shoot() = valve::g_global_vars->m_cur_time > g_eng_pred->postpone_fire_ready_time();
			}
			else {
				user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

				g_eng_pred->postpone_fire_ready_time() = valve::g_global_vars->m_cur_time + valve::to_time(15);

				g_eng_pred->r8_can_shoot() = false;
			}
		}

		if ((m_charged)
			&& (user_cmd.m_buttons & valve::e_buttons::in_attack))
			user_cmd.m_buttons &= ~valve::e_buttons::in_attack;

		g_context->flags() &= ~e_context_flags::recharge;

		if (g_anim_sync->local_data().m_shot_valid_wpn
			&& g_anim_sync->local_data().m_shot_cmd_number > valve::g_client_state->m_last_cmd_out
			&& g_anim_sync->local_data().m_shot_cmd_number < (valve::g_client_state->m_last_cmd_out + 100))
			g_context->flags() |= e_context_flags::recharge;

		g_context->flags() &= static_cast<e_context_flags>(~0x32u);

		if (m_charged)
			g_context->flags() &= ~e_context_flags::can_choke;
		else {
			if (m_type
				&& m_ticks_allowed) {
				if (valve::g_client_state->m_net_channel->m_choked_packets >= 1)
					g_context->flags() &= ~e_context_flags::can_choke;
				else
					g_context->flags() |= e_context_flags::can_choke;
			}
			else {
				if (valve::g_client_state->m_net_channel->m_choked_packets >= (((*valve::g_game_rules)->is_valve_ds() == true) ? 6 : 14))
					g_context->flags() &= ~e_context_flags::can_choke;
				else
					g_context->flags() |= e_context_flags::can_choke;
			}
		}

		if (g_context->can_shoot(weapon, user_cmd, g_eng_pred->r8_can_shoot(), shift_amount, false))
			g_context->flags() |= e_context_flags::can_shoot;
		else
			g_context->flags() &= ~e_context_flags::can_shoot;

		if (g_eng_pred->last_user_cmd().m_buttons & valve::e_buttons::in_attack) {
			if (weapon
				&& wpn_data
				&& wpn_data->m_unk_type == 2) {
				if (weapon->item_index() != valve::e_item_index::revolver)
					g_context->flags() &= ~e_context_flags::can_shoot;
			}
		}
	}

	bool c_exploits::try_to_recharge() {
		if ((valve::g_global_vars->m_cur_time - valve::g_local_player->spawn_time()) < 1.f)
			return false;

		if (m_recharge_cmd != valve::g_client_state->m_last_cmd_out
			&& (valve::g_client_state->m_choked_cmds || m_ticks_allowed >= (((*valve::g_game_rules)->is_valve_ds() == true) ? 6 : 14)))
			return false;

		if (!compute_type()
			|| g_context->should_return()
			|| g_context->flags() & e_context_flags::has_target
			|| std::abs(g_anim_sync->local_data().m_last_shot_time - valve::g_global_vars->m_cur_time) <= 0.1469f)
			return false;

		if (m_ticks_allowed >= (((*valve::g_game_rules)->is_valve_ds() == true) ? 6 : 14)) {
			m_charged = true;

			if ((m_ticks_allowed + 1) <= (((*valve::g_game_rules)->is_valve_ds() == true) ? 8 : 16)) {
				if (m_ticks_allowed < 0)
					m_ticks_allowed = 0;
			}
			else
				m_ticks_allowed = (((*valve::g_game_rules)->is_valve_ds() == true) ? 7 : 15);

			return false;
		}

		m_recharge_cmd = valve::g_client_state->m_last_cmd_out;

		if (++m_ticks_allowed > (((*valve::g_game_rules)->is_valve_ds() == true) ? 8 : 16))
			m_ticks_allowed = (((*valve::g_game_rules)->is_valve_ds() == true) ? 8 : 16);

		return true;
	}

	int c_exploits::calc_correction_ticks() const {
		return valve::g_global_vars->m_max_clients <= 1
			? -1 : valve::to_ticks(std::clamp(g_context->cvars().m_sv_clockcorrection_msecs->get_float() / 1000.f, 0.f, 1.f));
	}

	int c_exploits::adjust_tick_base(const int old_new_cmds, const int total_new_cmds, const int delta) const {
		auto ret = -1;

		const auto correction_ticks = calc_correction_ticks();
		if (correction_ticks != -1) {
			const auto& prev_local_data = g_eng_pred->local_data().at(valve::g_client_state->m_last_cmd_out % 150);
			if (prev_local_data.m_spawn_time == valve::g_local_player->spawn_time()) {
				ret = prev_local_data.m_tick_base + 1;

				const auto tick_count = ret + old_new_cmds - m_correction_amount;

				const auto ideal_final_tick = tick_count + correction_ticks;

				const auto too_fast_limit = ideal_final_tick + correction_ticks;
				const auto too_slow_limit = ideal_final_tick - correction_ticks;

				const auto estimated_final_tick = ret + total_new_cmds;

				if (estimated_final_tick > too_fast_limit
					|| estimated_final_tick < too_slow_limit) {
					ret = ideal_final_tick - total_new_cmds;
				}
			}
		}

		if (ret != -1)
			return ret;

		const auto& local_data = g_eng_pred->local_data().at((valve::g_client_state->m_last_cmd_out + 1) % 150);

		return (local_data.m_spawn_time == valve::g_local_player->spawn_time()
			? local_data.m_tick_base : valve::g_local_player->tick_base()) - delta;
	}

	void c_exploits::handle_other_shift(
		const std::uintptr_t ecx, const std::uintptr_t edx, const int slot,
		valve::bf_write_t* buffer, int& from, int& to, valve::move_msg_t* move_msg
	) {
		auto shift_amount = m_cur_shift_amount;
		m_cur_shift_amount = 0;

		const auto write_real_cmds = m_type == 2 || m_type == 3;

		const auto v86 = std::min(move_msg->m_new_cmds + m_ticks_allowed, (((*valve::g_game_rules)->is_valve_ds() == true) ? 8 : 16));

		int v69{};

		auto v70 = v86 - move_msg->m_new_cmds;
		if (write_real_cmds)
			v70 -= shift_amount;

		if (v70 >= 0)
			v69 = v70;

		m_ticks_allowed = v69;

		const auto old_new_cmds = move_msg->m_new_cmds;

		move_msg->m_new_cmds = std::clamp(move_msg->m_new_cmds + shift_amount, 1, 62);
		move_msg->m_backup_cmds = 0;

		auto first_tick_base = adjust_tick_base(old_new_cmds, move_msg->m_new_cmds, shift_amount);

		const auto next_cmd_number = valve::g_client_state->m_last_cmd_out + valve::g_client_state->m_choked_cmds + 1;

		for (to = next_cmd_number - old_new_cmds + 1; to <= next_cmd_number; ++to) {
			if (!hooks::orig_write_user_cmd_delta_to_buffer(ecx, edx, slot, buffer, from, to, true))
				return;

			from = to;
		}

		for (auto i = valve::g_client_state->m_last_cmd_out + 1; i <= next_cmd_number; ++i) {
			auto& local_data = hacks::g_eng_pred->local_data().at(i % 150);

			local_data.m_shift_amount = write_real_cmds ? 0 : shift_amount;
			local_data.m_override_tick_base = true;
			local_data.m_restore_tick_base = !write_real_cmds;
			local_data.m_adjusted_tick_base = first_tick_base++;
		}

		const auto user_cmd = valve::g_input->user_cmd(slot, from);
		if (!user_cmd)
			return;

		auto from_user_cmd = *user_cmd, to_user_cmd = *user_cmd;

		++to_user_cmd.m_number;

		valve::g_prediction->m_prev_start_frame = -1;
		valve::g_prediction->m_cmds_predicted = 0;

		vec2_t target_move{};

		if (write_real_cmds) {
			++valve::g_client_state->m_choked_cmds;
			++valve::g_client_state->m_net_channel->m_choked_packets;
			++valve::g_client_state->m_net_channel->m_out_seq_number;

			if (m_type != 3) {
				const auto& local_data = hacks::g_eng_pred->local_data().at(next_cmd_number % 150);
				target_move = { local_data.m_move.x, local_data.m_move.y };
			}

			int v80{};

			do {
				valve::g_prediction->update(
					valve::g_client_state->m_delta_tick,
					valve::g_client_state->m_delta_tick > 0,
					valve::g_client_state->m_last_cmd_ack,
					valve::g_client_state->m_last_cmd_out + valve::g_client_state->m_choked_cmds
				);

				to_user_cmd.m_buttons &= static_cast<valve::e_buttons>(~4290707449u);
				to_user_cmd.m_move = {};
			
				if (valve::g_local_player->alive()) {
					if (m_type != 3) {
						if (g_context->flags() & e_context_flags::aim_fire) {
							int v54{};
							if ((shift_amount - 2) >= 0)
								v54 = shift_amount - 2;

							if (v80 >= v54
								&& sdk::g_config_system->quick_stop) {
								hacks::g_movement->stop_type() = 1;
								hacks::g_movement->stop(to_user_cmd);
							}
							else {
								to_user_cmd.m_move.x = target_move.x;
								to_user_cmd.m_move.y = target_move.y;
							}
						}
					}

					if (g_context->should_return()) {
						const auto angle = math::calculate_angle(valve::g_local_player->abs_origin(), g_context->start_position());
						to_user_cmd.m_view_angles = angle;
						to_user_cmd.m_move.x = 450.f;
						to_user_cmd.m_move.y = 0.f;						
					}

					hacks::g_movement->force_lby_update(to_user_cmd);

					auto& local_data = hacks::g_eng_pred->local_data().at(to_user_cmd.m_number % 150);

					local_data.init(to_user_cmd);

					hacks::g_anim_sync->update_local(to_user_cmd.m_view_angles, true);

					local_data.save(to_user_cmd.m_number);
				}

				valve::g_input->m_cmds[to_user_cmd.m_number % 150] = to_user_cmd;
				valve::g_input->m_verified_cmds[to_user_cmd.m_number % 150] = { to_user_cmd, to_user_cmd.calc_checksum() };

				buffer->write_user_cmd(&to_user_cmd, &from_user_cmd);

				auto& local_data = hacks::g_eng_pred->local_data().at(to_user_cmd.m_number % 150);

				local_data.m_override_tick_base = true;
				local_data.m_adjusted_tick_base = first_tick_base++;

				++v80;

				if (v80 >= shift_amount)
					g_context->add_packet(valve::g_client_state->m_last_cmd_out + valve::g_client_state->m_choked_cmds + 1);
				else {
					++valve::g_client_state->m_choked_cmds;
					++valve::g_client_state->m_net_channel->m_choked_packets;
					++valve::g_client_state->m_net_channel->m_out_seq_number;
				}

				from_user_cmd = to_user_cmd;

				++to_user_cmd.m_number;
			} while (v80 < shift_amount);
		}
		else {
			to_user_cmd.m_tick = std::numeric_limits< int >::max();

			do {
				buffer->write_user_cmd(&to_user_cmd, &from_user_cmd);

				from_user_cmd = to_user_cmd;

				++to_user_cmd.m_number;
			} while (--shift_amount);
		}
	}
}